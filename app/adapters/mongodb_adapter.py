from adapters.base import AbstractStorageAdapter
from pydantic import BaseModel
from typing import List, Optional, Type, Any
import motor.motor_asyncio

from bson.objectid import ObjectId # Import ObjectId
from app.models.webhook import Webhook # Import Webhook model

class MongoDBAdapter(AbstractStorageAdapter):
    def __init__(self, connection_string: str, database_name: str):
        self.client = motor.motor_asyncio.AsyncIOMotorClient(connection_string)
        self.db = self.client[database_name]

    async def create(self, model_instance: BaseModel) -> BaseModel:
        """Creates a new record."""
        collection_name = model_instance.__class__.__name__.lower()
        collection = self.db[collection_name]
        # Convert Pydantic model to dictionary, excluding unset fields
        data = model_instance.model_dump(by_alias=True, exclude_unset=True)
        
        # Handle 'id' for Webhook model specifically, if it's not an ObjectId
        if isinstance(model_instance, Webhook) and model_instance.id:
            data['_id'] = model_instance.id
            # Ensure 'id' is not duplicated if it's already set as _id
            data.pop('id', None)
        
        result = await collection.insert_one(data)
        
        # If the Pydantic model has an 'id' field and it was generated by MongoDB, update it
        if hasattr(model_instance, 'id') and result.inserted_id and not getattr(model_instance, 'id', None):
            setattr(model_instance, 'id', str(result.inserted_id))
        return model_instance

    async def read(self, model_type: Type[BaseModel], id: Any) -> Optional[BaseModel]:
        """Reads a record by ID."""
        collection_name = model_type.__name__.lower()
        collection = self.db[collection_name]
        # Assume ID is stored as ObjectId in MongoDB
        try:
            object_id = ObjectId(str(id))
        except Exception:
            return None # Invalid ID format

        document = await collection.find_one({"_id": object_id})

        if document:
            # Convert MongoDB document to Pydantic model
            # Assuming MongoDB '_id' should map to Pydantic 'id'
            document['id'] = str(document.pop('_id'))
            return model_type.model_validate(document)
        return None

    async def update(self, model_instance: BaseModel) -> BaseModel:
        """Updates an existing record."""
        collection_name = model_instance.__class__.__name__.lower()
        collection = self.db[collection_name]
        # Get the document ID from the model instance using getattr for safety
        instance_id = getattr(model_instance, 'id', None)
        if instance_id is None:
             # Or raise a specific error if ID is required for update
            raise ValueError("Model instance must have an ID for update")

        try:
            object_id = ObjectId(str(instance_id))
        except Exception:
            raise ValueError(f"Invalid ID format: {instance_id}")

        # Convert Pydantic model to dictionary, excluding unset fields and the id/ _id field
        data = model_instance.model_dump(by_alias=True, exclude_unset=True, exclude={'id'})
        # MongoDB uses _id, so ensure it's not in the update data if it was somehow included
        data.pop('_id', None)


        result = await collection.replace_one({"_id": object_id}, data)

        if result.matched_count == 0:
            # Or raise a specific error if the document was not found
             raise ValueError(f"Document with ID {instance_id} not found for update")

        # Return the updated model instance
        return model_instance

    async def delete(self, model_type: Type[BaseModel], id: Any) -> None:
        """Deletes a record by ID."""
        collection_name = model_type.__name__.lower()
        collection = self.db[collection_name]

        try:
            object_id = ObjectId(str(id))
        except Exception:
            raise ValueError(f"Invalid ID format: {id}")

        result = await collection.delete_one({"_id": object_id})

        if result.deleted_count == 0:
            # Or raise a specific error if the document was not found
            raise ValueError(f"Document with ID {id} not found for deletion")

        # No return value for delete
        pass

    async def list(self, model_type: Type[BaseModel]) -> List[BaseModel]:
        """Lists all records of a given type."""
        collection_name = model_type.__name__.lower()
        collection = self.db[collection_name]

        documents = []
        async for document in collection.find():
            # Convert MongoDB document to Pydantic model
            # Assuming MongoDB '_id' should map to Pydantic 'id'
            document['id'] = str(document.pop('_id'))
            documents.append(model_type.model_validate(document))

        return documents